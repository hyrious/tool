<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width">
  <link rel="stylesheet" href="style.css">
  <script src="favicon.js"></script>
  <script src="theme.js"></script>
  <title>Octree</title>
  <style>
    .content label {
      display: block;
      border: 1px dashed var(--control);
      border-radius: 6px;
      padding: 3rem;
      text-align: center;
      cursor: pointer;
    }
    .content label.active {
      border: 1px solid;
    }
    .controls {
      border: 1px solid var(--control);
      border-radius: 6px;
      padding: 1rem;
    }
    output {
      display: flex;
      align-items: center;
    }
    span {
      padding: 0 0.5rem;
    }
    img, canvas {
      max-width: 400px;
    }
  </style>
</head>
<body>
  <h1 class="title">Octree</h1>

  <section class="controls">
    <label for="mc">Max Colors</label>
    <input id="mc" type="number" value="256">
  </section>

  <section class="content">
    <input id="f" type="file" accept="image/*" style="display: none">
    <label id="fl" for="f">drop image here</label>
  </section>

  <section>
    <output id="o"></output>
  </section>

  <script src="octree.js"></script>
  <script>
    f.labels[0].ondragover = e => e.preventDefault()
    f.labels[0].ondrop = e => e.preventDefault() ^ update(e.dataTransfer.files[0]) ^ (dragging = 0) ^ fl.classList.remove('active')
    let dragging = 0
    f.labels[0].ondragenter = e => e.preventDefault() ^ fl.classList.add('active') ^ (dragging++)
    f.labels[0].ondragleave = e => e.preventDefault() ^ (--dragging === 0 && fl.classList.remove('active'))
    f.oninput = _ => update(f.files[0])

    function update(file) {
      if (!file) return;
      let img = new Image()
      img.data = file.stream()
      img.type = file.type
      img.src = URL.createObjectURL(file)
      img.onload = _ => URL.revokeObjectURL(img.src) ^ main(img)
    }

    function getPixels(img) {
      const canvas = document.createElement('canvas')
      const w = canvas.width = img.naturalWidth
      const h = canvas.height = img.naturalHeight
      const c = canvas.getContext('2d')
      c.drawImage(img, 0, 0)
      return c.getImageData(0, 0, w, h)
    }

    function main(img) {
      // Reference:
      // https://observablehq.com/@tmcw/octree-color-quantization
      // https://github.com/NickeManarin/ScreenToGif/blob/-/ScreenToGif.Util/Codification/Gif/Encoder/Quantization/OctreeQuantizer.cs
      // https://github.com/olvb/colorcrush

      const { width, height, data } = getPixels(img)
      const pixels = new DataView(data.buffer)
      const { gen, Color } = octree

      const palette = gen(pixels, width, height, mc.valueAsNumber)

      const canvas = document.createElement('canvas')
      canvas.id = 'palette'
      canvas.style.imageRendering = 'pixelated'
      canvas.style.zoom = '5'
      canvas.width = canvas.height = 16
      const c = canvas.getContext('2d')
      for (let i = 0, len = palette.length; i < len; ++i) {
        const p = palette[i], x = i % 16, y = i >> 4
        c.fillStyle = `rgb(${[p.R, p.G, p.B]})`
        c.fillRect(x, y, 1, 1)
      }

      o.innerHTML = ''
      img.style.imageRendering = 'pixelated'
      o.appendChild(img)
      o.appendChild(document.createElement('span')).textContent = '—'
      o.appendChild(canvas)

      function paletteIndex(color) {
        let mindiff = Number.MAX_SAFE_INTEGER, index = -1
        for (let i = 0, len = palette.length; i < len; ++i) {
          const p = palette[i], diff = Color.diff(p, color)
          if (mindiff > diff) {
            mindiff = diff
            index = i
          }
        }
        return index
      }

      for (let i = 0, len = width * height; i < len; ++i) {
        const hex = pixels.getUint32(i << 2)
        if (Color.isTransparent(hex)) continue;
        const color = new Color(hex)
        const index = paletteIndex(color)
        if (index !== -1) {
          pixels.setUint32(i << 2, Color.encode(palette[index]))
        } else {
          throw new Error('wtf')
        }
      }
      const imageData = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height)
      const canvas2 = document.createElement('canvas')
      canvas2.width = width
      canvas2.height = height
      canvas2.style.imageRendering = 'pixelated'
      const c2 = canvas2.getContext('2d')
      c2.putImageData(imageData, 0, 0)

      o.appendChild(document.createElement('span')).textContent = '→'
      o.appendChild(canvas2)

      console.log(palette)
    }
  </script>
</body>
</html>
