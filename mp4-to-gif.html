<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="style.css">
  <script src="favicon.js"></script>
  <script src="theme.js"></script>
  <title>MP4 to GIF</title>
  <style>
    .error,
    .warning {
      margin: 0;
      padding: 1rem;
      background-color: rgba(255, 0, 0, 0.2);
    }
    .warning {
      background-color: rgba(255, 255, 0, 0.2);
    }
    .cli {
      font-family: monospace;
      min-width: 500px;
    }
    .info {
      padding: 1rem;
      font-size: 14px;
      padding: 0.5rem;
      background: var(--control);
    }
    .file {
      display: inline-block;
      margin: 1rem 0;
      padding: 1rem;
      border: 1px dashed var(--control);
      border-radius: 6px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="$progress" style="position:absolute;top:0;left:0;width:0%;height:2px;background:#add8e6;transition:opacity 1s,width .1s"></div>
  <h1 class="title">MP4 to GIF</h1>

  <section class="content" id="$content">
    <div class="gifsicle">
      <input id="$gifsicle" type="checkbox" checked>
      <label for="$gifsicle">Enable?</label>
      <label for="$options">Gifsicle Options:</label>
      <input id="$options" class="cli" value="-U -i -O2 -k 256 --resize-fit-width 100">
    </div>
    <input id="$file" style="display: none" type="file" accept="video/*">
    <label id="$file_label" for="$file" class="file">Drag & drop mp4 file here.</label>
    <samp id="$info" class="info" style="display: none"></samp>
    <samp id="$info2" class="info" style="display: none">(decoding frames)</samp>
    <select id="$fps" style="display: none">
      <option value="10">10 FPS</option>
      <option value="16">16 FPS</option>
      <option value="33" selected>33 FPS</option>
    </select>
    <label id="$format_label" for="$format" style="display: none">Format:</label>
    <select id="$format" style="display: none">
      <option value="rgb444">rgb444</option>
      <option value="rgb565" selected>rgb565</option>
    </select>
    <button id="$run" style="display: none">Convert!</button>
  </section>

  <section>
    <img src="" id="$output">
  </section>

  <section id="$not_supported" style="display: none">
    <p class="warning">
      Your browser does not support <a href="https://caniuse.com/webcodecs" rel="noreferrer" target="_blank">VideoDecoder</a>,
      please use the latest chrome to open this page.
    </p>
  </section>

  <script src="https://cdn.jsdelivr.net/npm/mp4box@0.5.2/dist/mp4box.all.min.js"></script>

  <script id="$worker" type="module/worker">
    /// https://github.com/mattdesl/gifenc/blob/HEAD/test/worker.js

    import { GIFEncoder, quantize, applyPalette } from 'https://cdn.jsdelivr.net/npm/gifenc@1.0.3/dist/gifenc.esm.js'

    var options

    onmessage = function onmessage(ev) {
      var detail = ev.data
      if (detail.event === 'init') {
        options = { ...detail }
        postMessage('ready')
      } else {
        var { format = 'rgb444', width, height, maxColors = 256, repeat = 0, delay = 0 } = options
        var [ data, frame ] = detail
        var palette = quantize(data, maxColors, { format })
        var index = applyPalette(data, palette, format)
        var gif = GIFEncoder({ auto: false })
        gif.writeFrame(index, width, height, { first: frame === 0, repeat: 0, delay, palette })
        var output = gif.bytesView()
        postMessage([ output, frame ], [output.buffer])
      }
    }
  </script>

  <script type="module">
    /// References:
    /// https://web.dev/webcodecs#decoding
    /// https://github.com/mattdesl/gifenc (MIT)
    ///
    /// Note: The decoding (mp4box & VideoDecoder) can be moved to workers, but I don't care.

    var gifenc_p = import('https://cdn.jsdelivr.net/npm/gifenc@1.0.3/dist/gifenc.esm.js')
    var gifsicle_p = import('https://cdn.jsdelivr.net/npm/gifsicle-wasm-browser@1.5.16/dist/gifsicle.min.js')

    if (!('VideoDecoder' in window)) {
      $not_supported.style.display = ''
      throw new Error('VideoDecoder is not supported, refuse to work.')
    }

    function noop() {}
    async function createWorkerEncoder(opts = {}) {
      var { progress = noop, totalFrames, width, height, fps = 33, maxColors = 256,
            workerCount = navigator.hardwareConcurrency || 4, format = 'rgb444' } = opts

      if (!totalFrames) throw new Error('missing totalFrames');
      if (!width || !height) throw new Error('missing width, height');

      var workerUrl = URL.createObjectURL(new Blob([ $worker.textContent ], { type: 'application/javascript' }))
      var workers = Array.from({ length: workerCount }, () => new Worker(workerUrl, { type: 'module' }))
      var frames = new Array(totalFrames).fill(null)
      var delay = 1000 / fps
      var remaining = totalFrames, workerIndex = 0
      var initMsg = { event: 'init', repeat: 0, delay, maxColors, width, height, format }
      for (var w of workers) w.postMessage(initMsg)
      await Promise.all(workers.map(waitForReady))
      var { GIFEncoder } = await gifenc_p
      var gif = GIFEncoder({ auto: false })

      function waitForReady(worker) {
        return new Promise(resolve => {
          function handler(ev) {
            if (ev.data === 'ready') {
              worker.removeEventListener('message', handler)
              resolve(ev)
            }
          }
          worker.addEventListener('message', handler, { passive: true })
        })
      }

      function nextProgress() {
        remaining--
        progress((totalFrames - remaining) / totalFrames)
      }

      function waitForFrame(worker, frame) {
        return new Promise(resolve => {
          function handler(ev) {
            if (ev.data[1] === frame) {
              worker.removeEventListener('message', handler)
              resolve(ev)
            }
          }
          worker.addEventListener('message', handler, { passive: true })
        })
      }

      return {
        addFrame(data, frame) {
          workerIndex = (workerIndex + 1) % workers.length
          var worker = workers[workerIndex]
          worker.postMessage([ data, frame ], [data.buffer])
          frames[frame] = waitForFrame(worker, frame).then(ev => {
            const [ data, frame ] = ev.data
            nextProgress()
            return data
          })
        },
        async finish() {
          var chunks = await Promise.all(frames)
          gif.writeHeader()
          for (var i = 0, len = chunks.length; i < len; ++i) {
            gif.stream.writeBytesView(chunks[i])
          }
          gif.finish()
          workers.forEach(w => w.terminate())
          workers.length = 0
          return gif.bytesView()
        },
      }
    }

    var encoder, decoder, mp4file, track, config, frames, raf

    function onReady(info) {
      track = info.videoTracks[0]
      config = {
        codec: track.codec,
        codedHeight: track.video.height,
        codedWidth: track.video.width,
        description: getDescription(track),
      }
      $info.textContent = `${config.codec} @ ${config.codedWidth}x${config.codedHeight}`
      $info.style.display = ''
      decoder.configure(config)

      mp4file.setExtractionOptions(track.id)
      mp4file.start()
      mp4file.flush()
      decoder.flush().then(processFrames)

      function getDescription(track) {
        const trak = mp4file.getTrackById(track.id)
        for (const entry of trak.mdia.minf.stbl.stsd.entries) {
          if (entry.avcC || entry.hvcC) {
            const stream = new DataStream(undefined, 0, DataStream.BIG_ENDIAN)
            if (entry.avcC) {
              entry.avcC.write(stream)
            } else {
              entry.hvcC.write(stream)
            }
            return new Uint8Array(stream.buffer, 8)
          }
        }
        return null
      }
    }

    function onSamples(trackId, ref, samples) {
      $info2.style.display = ''
      $format_label.style.display = ''
      $format.style.display = ''
      for (const sample of samples) {
        decoder.decode(new EncodedVideoChunk({
          type: sample.is_sync ? 'key' : 'delta',
          timestamp: 1e6 * sample.cts / sample.timescale,
          duration: 1e6 * sample.duration / sample.timescale,
          data: sample.data,
        }))
      }
    }

    async function loadFile(file) {
      if (!file) return;
      const buffer = await file.arrayBuffer()
      buffer.fileStart = 0

      frames = []
      decoder?.close()
      decoder = new VideoDecoder({
        output(frame) {
          const canvas = document.createElement('canvas')
          canvas.width = frame.displayWidth
          canvas.height = frame.displayHeight
          canvas.getContext('2d').drawImage(frame, 0, 0, frame.displayWidth, frame.displayHeight)
          canvas.timestamp = frame.timestamp // microseconds, (/ 1000) to get miliseconds
          frame.close() // ! this is important, otherwise the decoder will block forever
          frames.push(canvas)
          raf ||= requestAnimationFrame(refreshInfo)
        },
        error: console.error,
      })

      mp4file = MP4Box.createFile()
      mp4file.onError = console.error
      mp4file.onReady = onReady
      mp4file.onSamples = onSamples

      mp4file.appendBuffer(buffer)
      mp4file.flush()
    }

    function refreshInfo() {
      $info2.textContent = `(~${frames.length} frames)`
      raf = 0
    }

    function processFrames() {
      $info2.textContent = `(${frames.length} frames)`
      cancelAnimationFrame(raf)

      $fps.style.display = ''
      $run.style.display = ''
    }

    $file_label.ondragover = function onDragOver(ev) {
      ev.preventDefault()
      $file_label.classList.add('active')
    }
    $file_label.ondrop = function onDrop(ev) {
      ev.preventDefault()
      $file_label.classList.remove('active')
      loadFile(ev.dataTransfer.files[0])
    }
    $file.oninput = function onInput() {
      loadFile(this.files[0])
    }

    $run.onclick = async function run() {
      encoder = await createWorkerEncoder({
        totalFrames: frames.length,
        fps: parseInt($fps.value),
        format: $format.value,
        width: config.codedWidth,
        height: config.codedHeight,
        progress(p) {
          $progress.style.width = Math.round(p * 80) + '%'
          $progress.style.opacity = 1
        }
      })

      console.time('gifenc')
      var tick = Promise.resolve()
      for (var i = 0, len = frames.length; i < len; ++i) {
        const frame = frames[i]
        const { data } = frame.getContext('2d').getImageData(0, 0, frame.width, frame.height)
        encoder.addFrame(data, i)
        await tick
      }
      console.timeEnd('gifenc')

      var buffer = await encoder.finish()
      var blob = new Blob([buffer], { type: 'image/gif' })

      if ($gifsicle.checked) {
        $progress.style.width = '85%'
        $progress.style.opacity = 1

        var gifsicle = await gifsicle_p
        $progress.style.width = '95%'
        console.time('gifsicle')
        var [file] = await gifsicle.default.run({
          input: [{ file: blob, name: 'in.gif' }],
          command: ["in.gif " + $options.value + " -o /out/out.gif"],
        })
        console.timeEnd('gifsicle')

        blob = file
      }

      $output.src = URL.createObjectURL(blob);

      $progress.style.width = '100%'
      $progress.style.opacity = 0
    }
  </script>
</body>
</html>
